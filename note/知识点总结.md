## JSONP

详细博客链接：https://chenning02.github.io/2019/09/16/JSONP/

### JSONP案例

index.html

```html
<p>你的账户余额为<span id="amount">&&&amount&&&</span></p>
<button id="button">打钱</button>
<script>
button.addEventListener('click', (e)=>{
    let script = document.createElement('script')
    let functionName = 'chen'+parseInt(Math.random()*100000,10)
    window[functionName] = function(result){
        if(result === 'success'){
            amount.innerText = amount.innerText - 1
        }
    }
    script.src = 'http://ning.com:8002/pay?callback=' + functionName
    document.body.appendChild(script)
    script.onload = function(e){
        e.currentTarget.remove()
        delete window[functionName]
    }
    script.onerror = function(e){
        alert('fail')
        e.currentTarget.remove()
        delete window[functionName]
    }
})
</script>
```

server.js

```js
if(path === '/pay'/*  && method.toUpperCase() === 'POST' */){
    let amount = fs.readFileSync('./db', 'utf8')
    let newAmount = amount - 1
    fs.writeFileSync('./db', newAmount)
    response.setHeader('Content-Type', 'application/javascript')
    response.statusCode = 200
    response.write(`
		${query.callback}.call(undefined,'success')
    `)
    response.end()
}
```

**源代码链接**

https://github.com/ChenNing02/git-hunger/tree/master/course-demo/JSONP/6_JSONP

### 为什么JSONP无法发送POST请求

因为JSONP是通过动态创建script实现的，动态创建script时只能用GET 没办法用POST

## AJAX

详细博客链接：https://chenning02.github.io/2019/09/17/AJAX/

### 使用原生JS发送AJAX请求

```js
let request = new XMLHttpRequest()
request.open('get', 'http://xxx.com')
request.send()
request.onreadystatechange = ()=>{
    if(request.readyState === 4){
        if(request.status >= 200 && request.status < 300){
            let string = request.responseText
            let object = window.JSON.parse(string)
        }
    }
}
```

## 自制 Promise

源代码链接：Promise-z

### 封装方式

- 就是在原来的基础上添加函数，函数 `return new Promise(function(resolve,reject){})`

- 将要做的事都放到Promise传入的函数中

- return new Promise 中传入的函数的两个参数分别表示 成功调用的函数 和 失败调用的函数

### then 的作用

封装的函数在调用时可以 `.then` 传入两个函数，这两个函数对应封装时的两个参数 `resolve, reject` ，分别表示 成功后执行的函数 和 失败后执行的函数。

`.then()` 是 Promise 对象特有的

### 案例

**封装**

```js
window.jQuery.ajax = function ({url, method, body, headers}){ 
    return new Promise(function(resolve,reject){
        let request = new XMLHttpRequest()
        request.open(method, url)  // 配置 request
        for(let key in headers){
            let value = headers[key]
            request.setRequestHeader(key,value)
        }
        request.setRequestHeader('chen','16')
        request.onreadystatechange = ()=>{
            if(request.readyState === 4){
                if(request.status >= 200 && request.status < 300){
                    // 这里传入获取到的响应第四部分内容，当函数使用这个参数时，这就是回调函数
                    resolve.call(undefined,request.responseText) 
                }else if(request.status >= 400){
                    reject.call(undefined, request)
                }
            }
        }
        request.send(body)
    })
}
```

**调用**

```js
buttons.addEventListener('click', (e)=>{
    window.jQuery.ajax({
        url: '/xxx',
        method: 'POST',
        body: 'a=1&b=2',
        headers: {
            'content-type':'application/x-www-form-urlencoded',
            'chen':'16'
        }
    }).then(
        (text)=>{console.log(text)},
        (request)=>{console.log(request)}
    )    
})
```

**更易懂的调用方式**

```js
buttons.addEventListener('click', (e)=>{
    let promise = window.jQuery.ajax({
        url: '/xxx',
        method: 'POST',
        body: 'a=1&b=2',
        headers: {
            'content-type':'application/x-www-form-urlencoded',
            'chen':'16'
        }
    })
    promise.then(
        (text)=>{console.log(text)},
        (request)=>{console.log(request)}
    )    
})
```

