---
title: 参数处理 & 解构赋值
date: 2020-05-06 11:01:32
weight: 30
---

## 默认参数

### 函数默认参数

参数不存在时给一个默认参数

判断当 a 或 b 不存在时它们的值等于 0

之前的写法

```js
function sum(a, b){
    a = a || 0
    b = b || 0
    return a + b
}
```

**ES6写法**

```js
function sum(a=0, b=0){
    return a + b
}
```



## 剩余参数

例如，需要传入未知个数的参数，并将部分参数内容相加时：

之前的写法，遍历函数内 arguments 的每一项

```js
function sum(message){
    let result = 0
    for(let i=1; i<arguments.length; i++){
        result += arguments[i]
    }
    return message + result
}
sum('结果是：', 1, 2, 3, 4) // 输出："结果是：10"
```

**ES6写法**

当有多个不固定参数时，可以使用 `...numbers` 的写法

```js
function sum(message, ...numbers){
    let result = 0
    for(let i=0; i<numbers.length; i++){
        result += numbers[i]
    }
    return message + result
}
sum('结果是：', 1, 2, 3, 4) // 输出："结果是：10"
```

ES6写法简化

使用 `.reduce()` 方法简化循环的步骤

```js
function sum(message, ...numbers){
    let result = numbers.reduce((p, v)=>p+v, 0)
    return message + result
}
sum('结果是：', 1, 2, 3, 4) // 输出："结果是：10"
```

## 解构赋值

### 解构赋值+剩余参数

**将数组内容赋值给新变量**

```js
let array1 = [1, 2, 3, 4, 5, 6]
let [a, b, c, ...array2] = array1
console.log(array2) // [4, 5, 6]
```

将 array1 数组中的值分别赋值给 `a、b、c、array2` 其中 array2 是除了 a b c 前三个的剩余三个数组成的数组(`[4, 5, 6]`)

**在数组的前后分别追加内容**

ES6 写法

```js
let array1 = [1, 2, 3, 4, 5, 6]
let array2 = [0, ...array1, 7]
console.log(array2) // [0, 1, 2, 3, 4, 5, 6, 7]
```

而在 ES6 之前的写法就比较复杂了：

```js
let array1 = [1, 2, 3, 4, 5, 6]
let array2 = [0].concat(array1).concat([7])
console.log(array2) // 输出： [0, 1, 2, 3, 4, 5, 6, 7]
```

> 将数组[0]与数组array1与数组[7]拼接

### 赋值转换

```js
let a = 1
let b = 2
;[a, b] = [b, a] // 此处要加分号，否则这行代码会向上变为一行
console.log(a)
console.log(b)
```

### 解构赋值+对象

**使用数组批量赋值**

```js
let [a, b, ...rest] = [10, 20, 30, 40, 50]
```

> 注：不能在 `...rest` 后再追加变量，剩余参数只能放在最后，否则会出现语法歧义

**使用对象批量赋值**

之前的写法

```js
let sun = {name: 'isSun', age: 18, gender: 'Male'}
let name = sun.name
let age = sun.age
let gender = sun.gender
```

**ES6写法**

```js
let sun = {name: 'isSun', age: 18, gender: 'Male'}
let {name, age, gender} = sun
```

赋值时可通过对象属性名来修改变量名

```js
let sun = {
    name: 'Jack', age: 18, gender: 'Male'
}
let {name: xingMing} = sun
console.log(xingMing) // 输出：Jack
```

也可修改子对象属性名

```js
let sun = {
    name: 'Jack', age: 18, gender: 'Male', child: {
        name: 'Tom', age: 6, gender: 'Male'
    }
}
let {child: {name: xingMing}} = sun
console.log(xingMing) // 输出：Tom
```

给子对象赋值时也可添加默认参数，如果子对象没有该属性，则使用默认参数。

同时子对象的属性也可以使用批量声明。

```js
let sun = {
    name: 'Jack', age: 18, gender: 'Male', child: {
        name: 'Jerry', age: 6, gender: 'Male'
    }
}
let {child: {name: xingMing='Tom', age, gender}} = sun
console.log(xingMing) // 输出：Jerry
console.log(age, gender) // 输出：6 "Male"
```

### 解构赋值+默认参数

表示如果后面的数组中没有 a (没有第一项)，那么 a 的默认值是 5，如果后面的数组中没有 b (没有第二项)，那么 b 的默认值是 7 。

```js
let [a=5, b=7] = [1]
console.log(a)
console.log(b)
```

### 解构赋值+函数

函数返回值也可以用来赋值

```js
function fn(){
    return [1, 2]
}
let [a, b] = fn()
console.log(a)
console.log(b)
```

## 对象默认值

MDN文档链接：[函数参数默认值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#函数参数默认值)

**ES5写法**

判断传入的参数是否为空，空就存为一个空对象，判断对象内的属性是否为空，空就存一个默认值

```js
function drawES5Chart(options) {
  options = options === undefined ? {} : options;
  var size = options.size === undefined ? 'big' : options.size;
  var cords = options.cords === undefined ? { x: 0, y: 0 } : options.cords;
  var radius = options.radius === undefined ? 25 : options.radius;
  console.log(size, cords, radius);
  // now finally do some chart drawing
}

drawES5Chart({
  cords: { x: 18, y: 30 },
  radius: 30
});
```

**ES6写法**

判断传入的参数是否为空，空就存为一个空对象，判断对象内的每个属性是否为空，空就给一个默认值 (等于号后的就是默认值)

```js
function drawES2015Chart({size = 'big', cords = { x: 0, y: 0 }, radius = 25} = {}) 
{
  console.log(size, cords, radius);
  // do some chart drawing
}

drawES2015Chart({
  cords: { x: 18, y: 30 },
  radius: 30
});
```

简化上面的语法

```js
function drawES2015Chart(options = {})
{
  let {size = 'big', cords = { x: 0, y: 0 }, radius = 25} = options
  console.log(size, cords, radius);
  // do some chart drawing
}

drawES2015Chart({
  cords: { x: 18, y: 30 },
  radius: 30
});
```

## 对象浅拷贝

浅拷贝的概念

```js
let objA = {
    name: {
        x: 'a'
    }
}
let objB = Object.assign({}, objA)
objB.name.x = 'b'
console.log(objA.name) // {x: "b"}
```

上面就是浅拷贝，浅拷贝的内容只会拷贝第一层，所以对象内的属性还是指向相同的地址，还是都会被改变

**ES6的浅拷贝**

```js
let objA = {
    name: {
        x: 'a'
    }
}
let objB = {...objA}
console.log(objB) // {name: {x: "b"}}
```

## 对象合并

之前的方法

```js
let objA = {
    p1: 1,
    p2: 2
}
let objB = {
    p1: 1250,
    p3: 3
}
let objC = Object.assign({}, objA, objB)
console.log(objC) // 输出：{p1: 1250, p2: 2, p3: 3}
```

ES6新语法

```js
let objA = {
    p1: 1,
    p2: 2
}
let objB = {
    p1: 1250,
    p3: 3
}
let objC = {...objA, ...objB} // 后面的对象的属性会覆盖前面的相同属性
console.log(objC) // 输出：{p1: 1250, p2: 2, p3: 3}
```

## 对象属性加强

### 将变量赋值给对象的属性

之前的写法

```js
let x = 1
let y = 2
let obj = {
    "x": x,
    "y": y
}
```

ES6写法

```js
let x = 1
let y = 2
let obj = {x, y}
console.log(obj) // {x: 1, y: 2}
```

### 将对象的属性赋值给变量

ES6写法

```js
let obj = {x: 1, y: 2}
let {x, y} = obj
console.log(x) // 1
console.log(y) // 2
```

### 变量作为对象的 key

之前的写法

```js
let key = 'x'
let value = 'y'
let obj = {}
obj[key] = value
console.log(obj) // {x: "y"}
```

ES6写法

```js
let key = 'x'
let value = 'y'
let obj = {
    [key]: value
}
console.log(obj) // {x: "y"}
```

其中的中括号还可以做加法

```js
let key = 'x'
let value = 'y'
let obj = {
    [key + key]: value
}

console.log(obj) // {xx: "y"}
```

### 对象中属性及函数的多种写法

```js
let x = 1
let y = 2
let obj1 = {name: 1, age: 2}

let obj2 = {
    z: 1,
    x, // "x": x
    y,
    ...obj1,
    sayHi(name='jack'){},
    sayBye: function(){}
}
console.dir(obj2)
/* 输出：
{
    age: 2
    name: 1
    sayBye: ƒ ()
    sayHi: ƒ sayHi(name='jack')
    x: 1
    y: 2
    z: 1
}
*/
```