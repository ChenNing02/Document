---
title: this 是什么
date: 2020-05-06 20:01:02
---



## 结论

this 是 call 的第一个参数

## 函数的参数

### this 是 call 的第一个参数

声明一个函数

```js
function fn(p1, p2){
    console.log(p1)
}
```

当声明上面的函数时，做了以下的事情：

```js
function fn(p1, p2){
    /*
    创建了一个 arguments 数组对象
    在 arguments 数组中依次存入 p1, p2
    let arguments = [p1, p2]
    */
    console.log(p1)
}
```

其中 p1、p2 的值分别是 arguments 数组对象中的 第0个和第1个的值，而 this 就是 call 传入的第一个参数

```js
let object = {
    name: 'obj',
    hi: function(p1, p2){
        console.log(this.name)
    }
}
object.hi(1, 2)
// 等价于
object.hi.call(这里是this, 1, 2)
```

为了证明这一点，可以在 call 的时候第一个参数传入一个对象。案例：

```js
function fn(){
    console.log(this)
}

fn() // this 是 Window
fn.call({name: 'sum'}) // this 是 {name: 'sum'}
```

### 使用箭头函数取消 this

在 jQuery 中的使用 this

```js
let controller = {
    el: '#app',
    init: function(){
        let self = this // 将 this 的值存在 self 变量中
        $(this.el).on('click', function(p1, p2){
            this.xxx() // 此时的 this 就是 jQuery 中的被点击的当前元素
            self.xxx() // 此处的 self 才是 controller 对象
        })
    },
    xxx: function(){
        this.getUsers()
    },
    getUsers: function(){
        console.log('我是getUsers')
    }
}
```

由于 jQuery 会将 this 的值改变，所以需要在外面声明一个变量 self 来存储 this 的值

使用箭头函数优化代码

```js
let controller = {
    el: '#app',
    init: function(){
        let self = this // 将 this 的值存在 self 变量中
        $(this.el).on('click', (p1, p2)=>{
            this.xxx() // 此时的 this 就是外面的 this 因为箭头函数没有 this
        })
    },
    xxx: function(){
        this.getUsers()
    },
    getUsers: function(){
        console.log('我是getUsers')
    }
}
```

将 jQuery 中调用的函数换为箭头函数，由于箭头函数没有 this 值，所以它的 this 值会取外面的 this 值

JS Bin链接：https://jsbin.com/tiwitab/1/edit?html,js,output

## 面试题

### 下面的代码会在 console 输出什么？为什么？

```js
var myObject = {
    foo: "bar",
    func: function(){
        var self = this
        console.log("outer func: this.foo = " + this.foo)
        console.log("outer func: self.foo = " + self.foo)
        (function(){
            console.log("inner func: this.foo = " + this.foo)
            console.log("inner func: self.foo = " + self.foo)
        }())
    }
}
myObject.func()
```

答案

```js
outer func: this.foo = bar
outer func: self.foo = bar
inner func: this.foo = undefined
inner func: self.foo = bar
```

前两个 this

1. 通过向上查找到对象获取thsi，

2. 通过变量self确定this

立即执行函数中的this

1. 匿名函数 call 的第一个参数并没有，所以是 window 而 `window.foo` 是 undefined 。所以结果是 undefined

2. 通过外部变量 self  获取 this