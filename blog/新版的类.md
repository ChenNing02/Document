---
title: "新版的类"
date: 2020-05-26T10:53:27+08:00
slug: aef668e4
draft: false
weight: 100
---

MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes

## 原型（共有属性）

对象的原型链

```js
let o = {}
o.__proto__ === Object.prototype
```

数组的原型链

```js
let n = {}
n.__proto__ === Array.prototype
n.__proto__.__proto__ === Object.prototype
```

> 其他类型同理

## 类

**使用构造函数创建类**

```js
var 人类共有属性 = {
    walk(){ console.log('会走路') },
    species: '人类'
}
function createPerson(name, age){
    var obj = {}
    obj.name = name || ''
    obj.age = age || 18
    obj.__proto__ = 人类共有属性
    return obj
}
createPerson('jack') // {name: "jack", age: 18}
```

**自有属性 & 共有属性**

上面代码中的 `createPerson('jack')` 创建的对象中的 name，age 就是自有属性，而它的原型链中的 "人类共有属性" 对象中的属性就是共有属性

## class的用法

案例

```js
class Person{
    constructor(name){
        this.name = name
        this.age = 18
    }
    walk(){
        console.log('原地踏步')
    }
}

let p1 = new Person('chen') // {name: "chen", age: 18}
let p2 = new Person('jack') // {name: "jack", age: 18}

p1.walk === p2.walk // true
```

> 其中：constructor表示私有属性，外面的 `walk()` 表示共有属性，但在 class 语法中，共有属性必须是一个函数

- class 声明class类必须使用class
- new 如果你要生成一个类的对象，那么你就必须在类前加new
- constructor 每个类都要有一个 constructor 用来构造自有属性

**继承**

super 

继承了父类必须调用一次super

super 会将父类的属性传给子类

在调用this之前必须调用super()

使用案例

```js
class Animal{
    constructor(){
        this.body = '身体'
    }
    move(){
        console.log('能动')
    }
}
class Person extends Animal{
    constructor(name){
        super()
        this.body = this.body + '手脚'
        this.name = name
        this.age = 18
    }
    walk(){
        console.log('直立行走')
    }
}
let p1 = new Person('jack')
console.log(p1) //  {body: "身体手脚", name: "jack", age: 18}
console.log(p1.body) // 身体手脚
```

**class 的共有属性中添加其他类型值**

上面讲到，在 class 语法中，共有属性必须是一个函数，所以为了在共有属性中存储/修改其他类型值，需要对属性封装（使用get set函数添加其他类型值）。

在之前的案例中添加一个物种属性：

```js
class Animal{
    constructor(){
        this.body = '身体'
        this._race = 'xxx'
    }
    move(){
        console.log('能动')
    }
    get race(){
        return this._race
    }
    set race(value){
        this._race = value
    }
}
class Person extends Animal{
    constructor(name){
        super()
        this.body = this.body + '手脚'
        this.name = name
        this.age = 18
    }
    walk(){
        console.log('直立行走')
    }
}
let p1 = new Person('jack')
p1.race // "xxx"
p1.race = "动物"
p1.race // "动物"
```

> 缺点：这样做 还是会多余生成一个 _race

## 静态方法

```js
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;

        return Math.hypot(dx, dy);
    }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);

console.log(Point.distance(p1, p2));
```

上面的方法，可以使用

```js
Point.distance = function()(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.hypot(dx, dy);
}
```