---
title: "回调与回调地狱"
date: 2020-05-27T19:16:52+08:00
slug: c9e5bcfe
draft: false
weight: 110
---

普通函数调用

```js
function fn1(){
    console.log('xxx')
}
function fnx(msg){
    setTimeout(()=>{
        console.log(msg)
    }, 2000)
}
fnx('hi')
fn1()
```

上面的例子中即使fnx，先被调用，也会先执行 fn1，为了解决这个问题，就可以使用**回调函数**，如下：

```js
function fn1(){
    console.log('xxx')
}
function fnx(msg, callFn){
    setTimeout(()=>{
        console.log(msg)
        callFn() // 回调函数
    }, 2000)
}

fnx('hi',fn1) // hi  xxx
```

其中 fn1 在 fnx 的函数中被调用的方式就叫回调

为了容易理解，我们可以举一个更简单的例子。假如每次获取用户信息都要先打印用户信息，所以需要在获取中调用打印，如下：

```js
function 获取用户信息(fn){
    fn('姓名：jack')
}
function 打印用户信息(用户信息){
    console.log('这是我打印出来的用户信息')
    console.log(用户信息)
}
获取用户信息(打印用户信息)

// 输出：
// 这是我打印出来的用户信息
// 姓名：jack
```

上面的代码可以简化为，把"打印用户信息"函数作为匿名函数直接传入 "获取用户信息" 函数中，这种方法叫**匿名回调**，如下：

```js
function 获取用户信息(fn){
    fn('姓名：jack')
}
获取用户信息(function (用户信息){
    console.log('这是我打印出来的用户信息')
    console.log(用户信息)
})
```

但是如果使用匿名函数多次嵌套回调，很容易造成**回调地狱**，假如要获取 => 保存多个用户的信息，代码如下：

```js
function 获取用户信息(fn){
    fn('姓名：jack')
}
获取用户信息(function(用户信息){
    console.log(用户信息)
    保存用户信息(用户信息, function(){
        获取另一个用户的信息(function(另一个用户的信息){
            保存用户信息(另一个用户的信息)
        })
    })
})
```

**使用 Promise 解决回调地狱**

如果使用 Promise 上面的代码可以以下面的形式写：

```js
function 获取用户信息(){
    return new Promise(function(resolve, reject){
        console.log('第1次获取用户信息')
        resolve('姓名：杰克')
    })
}
function 打印用户信息(用户信息){
    return new Promise(function(resolve, reject){
        console.log(用户信息)
        resolve()
    })
}
function 获取另一个用户信息(){
    return new Promise(function(resolve, reject){
        console.log('第2次获取用户信息')
        resolve('姓名：小明')
    })
}
获取用户信息()
    .then(打印用户信息)
    .then(获取另一个用户信息)
    .then(打印用户信息)

// 输出：
// 第1次获取用户信息
// 姓名：杰克
// 第2次获取用户信息
// 姓名：小明
```

虽然 Promise 封装起来有些麻烦，但在调用时，相比回调地狱，结构更清晰。

Promise 的注意事项，以下面代码为例：

```js
function fn1(){
    return new Promise(function(resolve, reject){
        resolve()
    })
}
fn1()
    .then(S1, E1)
    .then(S2, E2)
    .then(S3, E3)
```

上面代码中：

当S1, E1都没有报错时（或返回resolve），执行S2。当S1，E1任何一个值有报错（或返回reject），就执行E2

当S2, E2都没有报错时（或返回resolve），执行S3。当S2，E2任何一个值有报错（或返回reject），就执行E3