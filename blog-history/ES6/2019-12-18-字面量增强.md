---
weight: 40
title: 字面量增强
---

## 字面量的含义

含义：它写出来就代表它写出来的意思

常见的字面量有：

```js
"hello"
1
{}
[1, 2, 3]
```

像 `new Object()` 这种构造函数就不属于字面量(非字面量：构造出的量)

## 更安全的二进制和八进制

ES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。

```javascript
0b111110111 === 503 // true
0o767 === 503 // true
```

从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。

```javascript
// 非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  'use strict';
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.
```

如果要将`0b`和`0o`前缀的字符串数值转为十进制，要使用`Number`方法。

```javascript
Number('0b111')  // 7
Number('0o10')  // 8
```

使用案例

```js
// 旧版语法
0777 // 输出 511
0888 // 输出 888
// 新版语法
0o777 // 输出511
0o888 // 报错
```

## 字符串支持 Unicode

特殊字符 (大于两个字节)

```js
'𝌆' === '\uD834\uDF06'
```

由于这个字符的存储编码是四个字节，所以JS会认为它是两个字符

```js
'𝌆'.length // 输出 2
```

获取某个字符串的字符编码

```js
'你'.charCodeAt().toString(16) // 输出 "4f60"
```

'你' 存储 `4F60` 所用空间 `0100 1111 0110 0000` 一共16位，而 '𝌆' 存储需要 32位

ES6 中有了新的 API 可以通过字符转换内容，也可以通过内容转换字符

```js
// 转内容
String.fromCodePoint(0x2F804) // 输出 '你' (这里的'你'是日文的你)
"你".length // 输出 2
// 转字符
"你".codePointAt(0).toString(16)
"2f804"
```

## Symbol

ES6 之前只有六种类型，分别是：`string number bool undefined null object`

ES6 增加了 symbol

假设我们需要做一个选择角色的种族的功能

```js
let race = {
    神族: 'protoss', 人族: 'terran', 虫族: 'zerg'
}
function createRole(input) {
    if(input === race.神族){ console.log('你选择了神族') }
    if(input === race.人族){ console.log('你选择了人族') }
    if(input === race.虫族){ console.log('你选择了虫族') }
}
createRole('protoss')
```

选择种族后，需要调用 createRole 来创建角色：

```js
// 传入字符串
createRole('protoss')
// 或者传入变量
createRole(race.神族)
```

一般传入字符串被认为是不好的做法，所以使用 `createRole(race.神族)` 的更多。

如果使用 `createRole(race.神族)`，那么你会发现一个问题：`race.神族、race.人族、race.虫族` 的值为多少并不重要。

将 race 对象中的每个属性的值改变，你会发现对选择的结果并无影响

```js
let race = {
    神族: 'xxxaa', 人族: 'xxxbb', 虫族: 'xxxcc'
}
```

也就是说：**race.zerg 的值是多少无所谓，只要它的值跟 race.protoss 和 race.terran 的值不一样就行。**

Symbol 的用途就是如此：Symbol 可以创建一个独一无二的值（但并不是字符串）。

用 Symbol 来改写上面的 race：

```js
var race = {
  神族: Symbol(),
  人族: Symbol(),
  虫族: Symbol()
}
// 判断三个属性的值是否相等
race.神族 !== race.人族 // true
race.神族 !== race.虫族 // true
```

你也可以给每个 Symbol 起一个名字：

```js
var race = {
  神族: Symbol('protoss'),
  人族: Symbol('terran'),
  虫族: Symbol('zerg')
}
```

不过这个名字跟 Symbol 的值并没有关系，你可以认为这个名字就是个注释。如下代码可以证明 Symbol 的名字与值无关：

```js
var a1 = Symbol('a')
var a2 = Symbol('a')
a1 !== a2 // true
```

总结：Symbol 生成一个全局唯一的值

## 迭代

一个简单的迭代，类似于循环，但是迭代不同的是次数是未知的

案例1

```js
function 发布器(){
    return {
        next: function(){
            return {
                name: 'frank'
            }
        }
    }
}
```

案例2

```js
function 发布器(){
    var _value = 0
    return {
        next: function(){
            _value += 1
            return {
                value: _value
            }
        }
    }
}
a = 发布器()
a.next()  // 输出 {value: 1}
a.next()  // 输出 {value: 2}
a.next()  // 输出 {value: 3}
```

案例3

```js
function 发布器(){
    var _value = 0
    var max = 5
    return {
        next: function(){
            _value += 1
            if(_value === max){
                return {value: _value, done: true}
            }else{
                return {
                  value: _value,
                  done: false
                }
            }
        }
    }
}
a = 发布器()
a.next() // 输出 {value: 1, done: false}
a.next() // 输出 {value: 2, done: false}
a.next() // 输出 {value: 3, done: false}
a.next() // 输出 {value: 4, done: false}
a.next() // 输出 {value: 5, done: true}
```

案例4

```js
function 发布器(){
    var _value = 0
    var max = 5
    return {
        next: function(){
            _value += 1
            if(_value > max){ throw new Error('你傻，已经没有下一个了') }
            if(_value === max){
                return {value: _value, done: true}
            }else{
                return {
                  value: _value,
                  done: false
                }
            }
        }
    }
}
a = 发布器()
a.next() // 输出 {value: 1, done: false}
a.next() // 输出 {value: 2, done: false}
a.next() // 输出 {value: 3, done: false}
a.next() // 输出 {value: 4, done: false}
a.next() // 输出 {value: 5, done: true}
a.next() // 报错 VM35:7 Uncaught Error: 你傻，已经没有下一个了
```

> 参考 MDN 文档：[迭代器和生成器 - 迭代器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E8%BF%AD%E4%BB%A3%E5%99%A8)

## 生成器

生成器就是迭代器**生成**的语法糖

```js
function* 发布器(){
    var version = 0
    while(true){
        version += 1
        yield version;
    }
}
a = 发布器()
a.next()
{value: 1, done: false}
a.next()
{value: 2, done: false}
a.next()
{value: 3, done: false}
...
```

yield 相当于在 while 循环中添加了一个开关，每次调用都会停止循环，将循环的变量现在的值 yield 出来，直到再次调用才会继续循环

## 可迭代对象

### for of

for of 是迭代器**访问**的语法糖，可迭代对象 (有 `.next()` 方法就是可迭代对象，俗称迭代行为)

可迭代案例

```js
let array = [1, 2, 3]
for(let item of array){
    console.log(item)
} // 输出 1 2 3
```

### 可迭代对象

**遍历数组**

普通遍历数组的方式：

```js
let array = [1, 2, 3]
for(let i = 0; i < array.length; i++){
    console.log(array[i])
} // 输出 1 2 3
```

上面的方式看似遍历出了数组的每一项，但是当我们给 array 数组添加一个属性时：

```js
array['x'] = 'y'
array // 输出 [1, 2, 3, x: "y"]
```

上面输出的数组中就不止有 1，2，3 了，但是通过普通的for循环遍历出来的依然只有 1，2，3 也就是说我们刻意只遍历了数字，我们所使用的遍历的不是真正的遍历

**遍历对象**

模拟数组生成一个对象

```js
object = {'0': 1, '1': 2, '2': 3, 'x': 'y'}
// 输出对象 {0: 1, 1: 2, 2: 3, x: "y"}
```

此时你会发现在对象中我们理论应该遍历所有属性，但是在数组中我们只会遍历数字下标的值，但是其实在数组中也并没有正真的数字下标，比如我们打出一个添加了 x 属性的数组

```js
let array = [1, 2, 3]
array['x'] = 'y'
Object.keys(array) // 输出 ["0", "1", "2", "x"]
```

此时你会发现上面的数组中并没有对 x 与数字值属性做区分

我们再将对象变成一个与数组看起来完全一样的数组

```js
// 对象变成数组
let object = {'0': 1, '1': 2, '2': 3, 'x': 'y'}
object.__proto__ = Array.prototype
object.length = 3
object // 输出 [1, 2, 3, x: "y"]
// 之前的数组
let array = [1, 2, 3]
array['x'] = 'y'
array // 输出 [1, 2, 3, x: "y"]
```

简单来说就是数组是一种特殊的对象，所以我们会认为数组就是有 0，1，2，3 有序的项，而对象就是有很多 key 与 value 组成的

而**可迭代对象**就是说有些对象是可迭代的，比如说数组

严格意义的遍历：

```js
let array = [1, 2, 3]
let object = {a: 1, b: 2, c: 3}
for(let key in array){
    console.log(key)
} // 输出 0 1 2
for(let key in object){
    console.log(key)
} // 输出 a b c
```

由上面的代码可看出数组与对象都可以遍历，但是只有数组是可迭代的，如下：

```js
for(let key of array){
    console.log(key)
} // 输出 1 2 3

for(let key of object){
    console.log(key)
} // 报错 Uncaught TypeError: object is not iterable (对象不可迭代)
```

总结：数组与对象都可以遍历，但是数组可以迭代，对象不能迭代

数组与对象的 key 与 value 在内存中存储时都是没有顺序的，只是我们在遍历数组时是按照 0 1 2 3 的顺序遍历，但是遍历对象时不会。数组与对象唯一的区别就是 数组的原型(`__proto__`)是指向`Array.prototype`而对象的原型是指向`Object.prototype`

只要是对象就可以被遍历，但是只有符合某些特征的对象才可以迭代

如果一个对象存在`[Symbol.iterator]`属性，说明是可迭代对象，例如上面的数组与对象对比：

```js
let array = [1, 2, 3]
let object = {a: 1, b: 2, c: 3}

array[Symbol.iterator]
// 输出 ƒ values() { [native code] }
object[Symbol.iterator]
// 输出 undefined
```

上面的例子说明了一个对象是否可以迭代的根本原因，就是它定义了一个迭代方法。

> 参考 MDN 文档：[迭代器和生成器 - 可迭代对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#可迭代对象)

案例

给上面的对象添加一个迭代方法，使它成为一个迭代对象

```js
let object = {a: 1, b: 2, c: 3}
object[Symbol.iterator] = function *(){
    yield 1;
    yield 2;
    yield 3;
}
for(let key of object){
    console.log(key)
} // 输出 1 2 3
```

添加一个与当前对象有关的迭代顺序

```js
let object = {a: 1, b: 2, c: 3}
object[Symbol.iterator] = function *(){
    let keys = Object.keys(object)
    for(let i = 0; i < keys.length; i++){
        yield object[keys[i]]
    }
}
for(let key of object){
    console.log(key)
} // 输出 1 2 3
```

之所以数组可以迭代，是因为数组是可以按照顺序遍历的，而对象无法按照顺序遍历，所以需要给它添加一个迭代方法让它按照某个顺序遍历，而这个迭代的方法就是一个Symbol方法，Symbol最初存在的意义就是为了实现可迭代对象。

------

参考文档：

> [ECMAScript 6 入门 - 二进制和八进制表示法](http://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)\
> [阮一峰 - Unicode与JavaScript详解](https://www.ruanyifeng.com/blog/2014/12/unicode.html)\
> [JS 中的 Symbol 是什么？](https://zhuanlan.zhihu.com/p/22652486?refer=study-fe)\
> [MDN - 迭代器和生成器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators)

